#!/usr/bin/env node

var _ = require('lodash');
var util = require('util');
var exit =  function (lnum, msg) {
  console.error(util.format('%d: [ERROR] %s', lnum, msg));
  process.exit(1);
}
var asm = '';
process.stdin.resume();
process.stdin.on('data', function (buf) { asm += buf.toString('utf8'); });
process.stdin.on('end', function () {
  var lines = asm.split(/\n|;/);

  // Pass 1
  var names = {};
  var base = 0;
  var macros = {};
  var mainProg = [];
  var inMain = false;
  var inNames = false;
  var inMacro = false;
  var macroProg = null;
  var codes = {
    'nop': 0,
    'ld_a_@c': 0x01,
    'add_@c': 0x02,
    'cmp_@c': 0x03,
    'nor_@c': 0x04,
    'ld_a_@b': 0x05,
    'bc_b': 0x09,
    'bz_b': 0x0a,
    'bu_b': 0x0b,
    'st_a_@b': 0x0c,
    'st_a_@c': 0x0d,
    'hlt': 0x0f,
    'ld_a': 0x10,
    'add': 0x20,
    'cmp': 0x30,
    'nor': 0x40,
    'out_a': 0x50,
    'in_a': 0x60,
    'ld_b0': 0x70,
    'ld_b1': 0x80,
    'ld_b2': 0x90,
    'ld_c0': 0xb0,
    'ld_c1': 0xc0,
    'ld_c2': 0xd0,
    'ld_b0_a': 0xf0,
    'ld_b1_a': 0xf1,
    'ld_b2_a': 0xf2,
    'ld_c0_a': 0xf4,
    'ld_c1_a': 0xf5,
    'ld_c2_a': 0xf6,
    'ld_b0_@c': 0xf8,
    'ld_b1_@c': 0xf9,
    'ld_b2_@c': 0xfa,
    'ld_c0_@b': 0xfc,
    'ld_c1_@b': 0xfd,
    'ld_c2_@b': 0xfe,
  };
  var numOfArgs = function (code) {
    return ((code | 0x0f) !== 0x0f && (code & 0xf0) !== 0xf0) ? 1 : 0;
  };
  var parseArg = function (arg, lnum) {
    var parts0 = arg.split('/')
    if (parts0.length === 2) {
      var name = parts0[0];
      var slice;
      var step;
      var parts1 = parts0[1].split('+')
      if (parts1.length === 2) {
        slice = parseInt(parts1[0]);
        step = parseInt(parts1[1]);
        if (isNaN(step) || step > 3) {
          exit(lnum, util.format('"%s" invalid step', arg));
        }
      }
      else {
        slice = parseInt(parts0[1]);
      }
      if (isNaN(slice) || slice > 3) {
        exit(lnum, util.format('"%s" invalid slice', arg));
      }
      return { name: name, slice: slice, step: step };
    }
    else if (arg.startsWith('0x')) {
      var hexVal = arg.substr(2);
      return { lit: parseInt(hexVal, 16), size: hexVal.length };
    }
    else {
      return { name: arg };
    }
  };
  for (var i = 0; i < lines.length; ++i) {
    var lnum = i + 1;
    var tokens = _.takeWhile(lines[i].split(/\t| /).filter(function (t) { return t.length; }), function (t) { return t !== '%'; });
    if (!tokens.length) continue;
    if (tokens[0] === 'end' && (inMain || inNames || inMacro)) {
      inMain = false;
      inNames = false;
      inMacro = false;
    }
    else if (inNames) {
      var parts = tokens[0].split('=0x')
      if (parts.length === 2) {
        var val;
        if (isNaN(val = parseInt(parts[1], 16))) {
          exit(lnum, util.format('"%s" invalid hexadecimal', parts[1]));
        }
        names[parts[0]] = { val: val, size: parts[1].length };
      }
      else {
        parts = tokens[0].split('*')
        if (parts.length === 2) {
          var size;
          if (isNaN(size = parseInt(parts[1]))) {
            exit(lnum, util.format('"%s" invalid name size', parts[1]));
          }
          if (size == 2) {
            while (((base & 0xf) | 0xe) !== 0xe) {
              base++;
            }
          }
          else if (size > 2 && size <= 4) {
            while (((base & 0xf) | 0xc) !== 0xc) {
              base++;
            }
          }
          names[parts[0]] = { val: base, size: 4, alloc: true };
          base += size;
        }
      }
    }
    else if (inMain || inMacro) {
      var label = null;
      var y = 0;
      if (tokens[y].length > 1 && tokens[y][tokens[y].length - 1] === ':') {
        label = tokens[y].substr(0, tokens[y].length - 1);
        y += 1;
      }
      var name = tokens[y];
      var args = _.map(tokens.slice(y + 1), function (arg) { return parseArg(arg, lnum); });
      var code;
      var p;
      if ((code = codes[name]) !== undefined) {
        var expNumOfArgs = numOfArgs(code)
        if (expNumOfArgs > args.length) {
          exit(lnum, util.format('"%s" has less arguments than expected', name));
        }
        else if (expNumOfArgs < args.length) {
          exit(lnum, util.format('"%s" has more arguments than expected', name));
        }
        p = {code: code, args: args, label: label, lnum: lnum};
      }
      else {
        p = {macro: name, args: args, label: label, lnum: lnum};
      }
      if (inMain) {
        mainProg.push(p);
      }
      else if (inMacro) {
        macroProg.push(p);
      }
    }
    else if (tokens[0] === 'names') {
      inNames = true;
    }
    else if (tokens[0] === 'main') {
      inMain = true;
    }
    else if (tokens[0] === 'macro' && tokens.length > 1) {
      inMacro = true;
      macroProg = [];
      macros[tokens[1]] = { prog: macroProg, aliases: tokens.slice(2) };
    }
  }

  // Pass 2
  var addr = 0;
  var objProg = [];
  var nextNamespace = 0;
  var generate = function (prog, renaming, namespace) {
    var renameArg = function (arg) {
      if (arg.lit !== undefined) {
        return arg;
      }
      else {
        var renamedArg;
        if (renamedArg = renaming[arg.name]) {
          if (renamedArg.lit !== undefined) {
            if (arg.slice !== undefined) {
              if (arg.slice < 0 || arg.slice >= renamedArg.size) {
                exit(lnum, util.format('"0x%s/%d" slice is to large; maximum is %d', renamedArg.lit.toString(16), arg.slice, renamedArg.size - 1));
              }
              delete arg.name;
              arg.lit = (((renamedArg.lit >> (arg.slice * 4)) + (arg.step === undefined ? 0 : arg.step)) & 0xf);
              arg.size = 1;
              return arg;
            }
            else {
              return renamedArg;
            }
          }
          else {
            if (arg.slice !== undefined) {
              if (renamedArg.slice !== undefined) {
                exit(p.lnum, util.format('"%s" is double-sliced', renamedArg.name));
              }
              arg.name = renamedArg.name;
              return arg;
            }
            else {
              return renamedArg;
            }
          }
        }
        else {
          arg.name += namespace;
          return arg;
        }
      }
    };
    for (var i = 0; i < prog.length; ++i) {
      var p = _.cloneDeep(prog[i]);
      p.args = _.map(p.args, renameArg)
      var label = p.label;
      if (label) {
        label += namespace;
        var name;
        if (name = names[label]) {
          if (name.label) {
            exit(p.lnum, util.format('"%s" used as label more than once', label));
            process.exit(1);
          }
          if (name.alloc) {
            exit(p.lnum, util.format('"%s" RAM allocation cannot be used as label', label));
          }
          if (name.size !== 4) {
            exit(p.lnum, util.format('"%s" label must be of size 4', label));
          }
          addr = name.val;
          name.label = true;
        }
        else {
          names[label] = { val: addr, size: 4, label: true };
        }
      }
      if (p.code !== undefined) {
        if (objProg[addr]) {
          exit(p.lnum, util.format('ROM placement conflict at 0x%s', addr.toString(16)));
        }
        objProg[addr] = p;
        addr += 1;
      }
      else {
        var macro;
        if ((macro = macros[p.macro]) !== undefined) {
          if (macro.aliases.length !== p.args.length) {
            exit(p.lnum, util.format('invalid number of macro arguments for "%s"', p.macro));
          }
          var macroRenaming = {};
          for (var k = 0; k < macro.aliases.length; ++k) {
            var alias = macro.aliases[k];
            var arg = p.args[k];
            macroRenaming[alias] = arg;
          }
          generate(macro.prog, macroRenaming, nextNamespace.toString(16));
          nextNamespace++;
        }
        else {
          exit(p.lnum, util.format('"%s" macro is undefined', p.macro));
        }
      }
    }
  }
  generate(mainProg, {}, '');

  // Pass 3
  var resolveArg = function (arg, expSize, lnum) {
    if (arg.lit !== undefined) {
      if (arg.size != expSize) {
        exit(lnum, util.format('"0x%s" literal size of %d is invalid; expected size %d', arg.lit.toString(16), arg.size, expSize));
        process.exit(1);
      }
      return arg.lit;
    }
    else {
      var name;
      if (name = names[arg.name]) {
        if (arg.slice !== undefined) {
          if (arg.slice < 0 || arg.slice >= name.size) {
            exit(lnum, util.format('"%s/%d" slice is to large; maximum is %d', arg.name, arg.slice, name.size - 1));
          }
          return (((name.val >> (arg.slice * 4)) + (arg.step === undefined ? 0 : arg.step)) & 0xf);
        }
        else {
          if (name.size != expSize) {
            exit(lnum, util.format('"%s*%d" size mismatch; expected size %d', arg.name, name.size, expSize));
          }
          return name.val;
        }
      }
      else {
        exit(lnum, util.format('"%s" name is not defined', arg.name));
      }
    }
  };
  var obj = new Buffer(8192);
  obj.fill(0xf);
  obj.writeWithArg = function (code, immediate, addr) {
    this.writeUInt8(code | (immediate & 0xf), addr);
  };
  for (var i = 0; i < objProg.length; ++i) {
    var p;
    if (p = objProg[i]) {
      //console.error('0x' + i.toString(16) + ' ' + p.lnum)
      if (p.args.length === 1) {
        obj.writeWithArg(p.code, resolveArg(p.args[0], 1, p.lnum), i);
      }
      else {
        obj.writeUInt8(p.code, i);
      }
    }
  }
  process.stdout.write(obj);
});
